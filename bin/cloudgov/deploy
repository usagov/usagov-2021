#!/bin/sh
#
# This script will attempt to create the services required
# and then launch everything.
#

if [ -f /home/circleci/project/env.local ]; then
  . /home/circleci/project/env.local
fi

DOCKERUSER=dnark
DOCKERREPO=usagov-2021

CONTAINERTAG=${1:-latest}
# The Image digest for this tag should be looked up from cloud.gov storage
# Any tag with a stored Image digest should be referenced by hash instead of tag

# this function will generate a random string, or bail if uuidgen is not available.
generate_string()
{
  if [ -z "$1" ] ; then
    if command -v uuidgen >/dev/null ; then
      NEW_STRING=$(uuidgen)
      export NEW_STRING
    else
      echo "cannot find uuidgen utility:  You will need to generate some random strings and put them in the CRON_KEY, HASH_SALT, and ROOT_USER_PASS environment variables, then re-run this script."
      exit 1
    fi
  fi
}

# If the user does not supply required data, generate some secrets.
generate_string "$CRON_KEY"
CRON_KEY=${CRON_KEY:-$NEW_STRING}

generate_string "$HASH_SALT"
HASH_SALT=${HASH_SALT:-$NEW_STRING}

generate_string "$ROOT_USER_PASS"
ROOT_USER_PASS=${ROOT_USER_PASS:-$NEW_STRING}

ROOT_USER_NAME=${ROOT_USER_NAME:-root}

# New Relic vars need to exist in the environment when this script runs
# they cannot be set to any reasonable defaults
NEW_RELIC_DISPLAY_NAME=${NEW_RELIC_DISPLAY_NAME:-}
NEW_RELIC_APP_NAME=${NEW_RELIC_APP_NAME:-}
NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY:-}
NEW_RELIC_API_KEY=${NEW_RELIC_API_KEY:-}


# function to check if a service exists
service_exists()
{
  cf service "$1" >/dev/null 2>&1
}

# create services (if needed)
if service_exists "database" ; then
  echo database already created
else
  #if [ "$SPACE" = "prod" ] ; then
  #  cf create-service aws-rds medium-mysql database
  #else
    cf create-service aws-rds \
      small-mysql \
      database \
      -c '{"version": "8.0"}'
  #fi
fi

if service_exists "secrets" ; then
  echo "secrets already created"
  CURR_SECRETS=$(cf curl /v2/user_provided_service_instances/$(cf service secrets --guid))
  CURR_CRON_KEY=$(echo $CURR_SECRETS | jq -r '.entity.credentials.CRON_KEY')
  CURR_HASH_SALT=$(echo $CURR_SECRETS | jq -r '.entity.credentials.HASH_SALT')
  CURR_ROOT_USER_NAME=$(echo $CURR_SECRETS | jq -r '.entity.credentials.ROOT_USER_NAME')
  CURR_ROOT_USER_PASS=$(echo $CURR_SECRETS | jq -r '.entity.credentials.ROOT_USER_PASS')
  CURR_NEW_RELIC_DISPLAY_NAME=$(echo $CURR_SECRETS | jq -r '.entity.credentials.NEW_RELIC_DISPLAY_NAME')
  CURR_NEW_RELIC_APP_NAME=$(echo $CURR_SECRETS | jq -r '.entity.credentials.NEW_RELIC_APP_NAME')
  CURR_NEW_RELIC_LICENSE_KEY=$(echo $CURR_SECRETS | jq -r '.entity.credentials.NEW_RELIC_LICENSE_KEY')
  CURR_NEW_RELIC_API_KEY=$(echo $CURR_SECRETS | jq -r '.entity.credentials.NEW_RELIC_API_KEY')
  if [ -n "$NEW_RELIC_DISPLAY_NAME" ] && [ "$CURR_NEW_RELIC_DISPLAY_NAME" != "$NEW_RELIC_DISPLAY_NAME" ] ; then
    CURR_NEW_RELIC_DISPLAY_NAME=${NEW_RELIC_DISPLAY_NAME}
  fi
  if [ -n "$NEW_RELIC_APP_NAME" ] && [ "$CURR_NEW_RELIC_APP_NAME" != "$NEW_RELIC_APP_NAME" ] ; then
    CURR_NEW_RELIC_APP_NAME=${NEW_RELIC_APP_NAME}
  fi
  if [ -n "$NEW_RELIC_LICENSE_KEY" ] && [ "$CURR_NEW_RELIC_LICENSE_KEY" != "$NEW_RELIC_LICENSE_KEY" ] ; then
    CURR_NEW_RELIC_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
  fi
  if [ -n "$NEW_RELIC_API_KEY" ] && [ "$CURR_NEW_RELIC_API_KEY" != "$NEW_RELIC_API_KEY" ] ; then
    CURR_NEW_RELIC_API_KEY=${NEW_RELIC_API_KEY}
  fi

  # Only allow update of new relic vars, all others match the existing values
  yes '' | cf update-user-provided-service secrets -p "{\"CRON_KEY\": \"$CURR_CRON_KEY\", \"HASH_SALT\": \"$CURR_HASH_SALT\", \"ROOT_USER_NAME\": \"$CURR_ROOT_USER_NAME\", \"ROOT_USER_PASS\": \"$CURR_ROOT_USER_PASS\", \"NEW_RELIC_DISPLAY_NAME\": \"$CURR_NEW_RELIC_DISPLAY_NAME\", \"NEW_RELIC_APP_NAME\": \"$CURR_NEW_RELIC_APP_NAME\", \"NEW_RELIC_LICENSE_KEY\": \"$CURR_NEW_RELIC_LICENSE_KEY\", \"NEW_RELIC_API_KEY\": \"$CURR_NEW_RELIC_API_KEY\"}"
  # do we need to reattach this service to the apps individually?

else
  yes '' | cf create-user-provided-service secrets -p "{\"CRON_KEY\": \"$CRON_KEY\", \"HASH_SALT\": \"$HASH_SALT\", \"ROOT_USER_NAME\": \"$ROOT_USER_NAME\", \"ROOT_USER_PASS\": \"$ROOT_USER_PASS\", \"NEW_RELIC_DISPLAY_NAME\": \"$NEW_RELIC_DISPLAY_NAME\", \"NEW_RELIC_APP_NAME\": \"$NEW_RELIC_APP_NAME\", \"NEW_RELIC_LICENSE_KEY\": \"$NEW_RELIC_LICENSE_KEY\", \"NEW_RELIC_API_KEY\": \"$NEW_RELIC_API_KEY\"}"
fi

if service_exists "secauthsecrets" ; then
  echo secauthsecrets already created
else
  mkdir -p /tmp/sp

  openssl req -new -x509 -days 3652 -nodes -out /tmp/sp/sp.crt -keyout /tmp/sp/sp.key -batch

  # Couldn't find a way to grap these without being written to disk.
  spkey=$(</tmp/sp/sp.key)
  spcrt=$(</tmp/sp/sp.crt)

  # convert sp.key to single line
  spkeyf=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' /tmp/sp/sp.key)

  # convert sp.crt to single line
  spcrtf=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' /tmp/sp/sp.crt)

  yes '' | cf create-user-provided-service secauthsecrets -p "{\"spcrt\": \"$spcrtf\", \"spkey\": \"$spkeyf\"}"

  # clean up
  rm -rf /tmp/sp
fi

if service_exists "storage" ; then
  echo storage already created
else
  cf create-service s3 basic-sandbox storage
fi

if service_exists "dbstorage" ; then
  echo dbstorage already created
else
  cf create-service s3 basic-sandbox dbstorage
fi

# wait until the db is fully provisioned
until cf create-service-key database test-db-ok ; do
	echo waiting until database is live...
	sleep 20
done
cf delete-service-key database test-db-ok -f

# make sure that the app knows where s3fs stuff lives
# we can make the assumption that the app exists during this step
cf create-service-key storage storagekey
S3INFO=$(cf service-key storage storagekey)
S3_BUCKET=$(echo "$S3INFO" | grep '"bucket":' | sed 's/.*"bucket": "\(.*\)",/\1/')
S3_REGION=$(echo "$S3INFO" | grep '"region":' | sed 's/.*"region": "\(.*\)",/\1/')
cf set-env cms S3_BUCKET "$S3_BUCKET"
cf set-env cms S3_REGION "$S3_REGION"
cf set-env waf S3_PROXY "$S3_BUCKET.s3-fips.$S3_REGION.amazonaws.com"
cf delete-service-key storage storagekey -f

# launch the apps
echo "cf push cms --docker-image $DOCKERUSER/$DOCKERREPO:cms-$CONTAINERTAG"
cf push cms --docker-image $DOCKERUSER/$DOCKERREPO:cms-$CONTAINERTAG

#cf restart cms
#cf restart waf
