#!/usr/bin/env bash
# Deploys or updates the services for the cronrunner app. This includes:
# - public-api-storage: The s3 bucket for the latest results
# - cron-runner-creds: The user-provided service for secrets.
#
# The "secrets" for the app must be available from the environment (possibly via env.local).
# If these are not set, the user-provided secrets service will not be created/updated:
#   CALL_CENTER_ENVIRONMENT
#   CALL_CENTER_CLIENT_ID
#   CALL_CENTER_CLIENT_SECRET
#   CALL_CENTER_EN_QUEUE_ID
#   CALL_CENTER_SP_QUEUE_ID

# this function is a convenient semantic wrapper
service_exists()
{
  cf service "$1" >/dev/null 2>&1
}

# cf target -s tools

# we might be running in circleci
if [ -f /home/circleci/project/env.local ]; then
  . /home/circleci/project/env.local
fi
# we might be running from a local dev machine
SCRIPT_DIR="$(dirname "$0")"
if [ -f $SCRIPT_DIR/env.local ]; then
  . $SCRIPT_DIR/env.local
fi
if [ -f ./env.local ]; then
  . ./env.local
fi


## Credentials service -- lots of pre-checks on this one.
CREDS_INSTANCE_NAME=cron-runner-creds

# Check for cron-runner creds. If all are present in the environment,
# we can create or update the service.  If any are missing, we can
# leave the service alone, if present, and proceed to refresh the S3
# service. If creds are missing and the service does not exist,
# someone has probably made a mistake.
env_checks=()

if [ -z "$CALL_CENTER_ENVIRONMENT" ]; then
  env_checks+=( "CALL_CENTER_ENVIRONMENT" )
fi
if [ -z "$CALL_CENTER_CLIENT_ID" ]; then
  env_checks+=( "CALL_CENTER_CLIENT_ID" )
fi
if [ -z "$CALL_CENTER_CLIENT_SECRET" ]; then
  env_checks+=( "CALL_CENTER_CLIENT_SECRET" )
fi
if [ -z "$CALL_CENTER_EN_QUEUE_ID" ]; then
  env_checks+=( "CALL_CENTER_EN_QUEUE_ID" )
fi
if [ -z "$CALL_CENTER_SP_QUEUE_ID" ]; then
  env_checks+=( "CALL_CENTER_SP_QUEUE_ID" )
fi

if (( ${#env_checks[@]} )); then
  err_msg="The following variables are missing:"
  for t in "${env_checks[@]}"; do
    err_msg+=" $t"
  done

  # Create or update cron-runner creds
  if service_exists "${CREDS_INSTANCE_NAME}" ; then
      echo "Credentials are not present in environment, proceeding without updating ${CREDS_INSTANCE_NAME}"
      echo $err_msg
  else
      echo "ERR! Must populate credentials in env.local to set up ${CREDS_INSTANCE_NAME}"
      echo "$err_msg"
      exit 1
  fi

else # Env checks all passed; create or update the credentials service.
    # Helpful post about using jq to create or update JSON: https://spin.atomicobject.com/jq-creating-updating-json/
    CREDS_JSON=$(jq --null-input \
		    --arg cc_env "${CALL_CENTER_ENVIRONMENT}" \
		    --arg cc_client_id "${CALL_CENTER_CLIENT_ID}" \
		    --arg cc_client_secret "${CALL_CENTER_CLIENT_SECRET}" \
		    --arg cc_en_q_id "${CALL_CENTER_EN_QUEUE_ID}" \
		    --arg cc_sp_q_id "${CALL_CENTER_SP_QUEUE_ID}" \
		    '{"CALL_CENTER_ENVIRONMENT":$cc_env,"CALL_CENTER_CLIENT_ID":$cc_client_id,"CALL_CENTER_CLIENT_SECRET": $cc_client_secret,"CALL_CENTER_EN_QUEUE_ID": $cc_en_q_id,"CALL_CENTER_SP_QUEUE_ID": $cc_sp_q_id}')
    # Hard to find docs on this, but it looks like `cf uups` and `cf cuups` want a JSON string without spaces between arguments.
    CREDS_JSON_ESCAPED=$( echo $CREDS_JSON | sed 's/"/\\"/g' | sed 's/ //g' )

    if service_exists "${CREDS_INSTANCE_NAME}" ; then
	echo "${CREDS_INSTANCE_NAME} user provided service already exists"
	echo " ... will update credentials in existing service."
	cf uups "${CREDS_INSTANCE_NAME}" -p "\""$CREDS_JSON_ESCAPED"\""
    else
	echo "Creating ${CREDS_INSTANCE_NAME}"
	cf cups "${CREDS_INSTANCE_NAME}" -p "\""$CREDS_JSON_ESCAPED"\""
    fi
fi

exit 0

## The s3 bucket for call center API results
{
    SERVICE_INSTANCE_NAME=public-api-storage
    KEY_NAME=tmp-public-api-storage-keys
    echo "Configuring ${SERVICE_INSTANCE_NAME} s3 service"
    if service_exists "${SERVICE_INSTANCE_NAME}" ; then
	echo "${SERVICE_INSTANCE_NAME} s3 bucket already exists"
    else
	echo "creating the service"
	cf create-service s3 basic-sandbox "${SERVICE_INSTANCE_NAME}"
    fi

    # Get credentials so we can set a CORS policy on the bucket
    # (The loop is here in case we have to wait for the service to be ready.)
    until cf create-service-key "${SERVICE_INSTANCE_NAME}" "$KEY_NAME"  ; do
	echo "waiting for access to ${SERVICE_INSTANCE_NAME} service ..."
	sleep 20
    done
    S3_CREDENTIALS=$(cf service-key "${SERVICE_INSTANCE_NAME}" "${KEY_NAME}" | tail -n +2)
    export AWS_ACCESS_KEY_ID=$(echo "${S3_CREDENTIALS}" | jq -r '.credentials.access_key_id')
    export AWS_SECRET_ACCESS_KEY=$(echo "${S3_CREDENTIALS}" | jq -r '.credentials.secret_access_key')
    export BUCKET_NAME=$(echo "${S3_CREDENTIALS}" | jq -r '.credentials.bucket')
    export AWS_DEFAULT_REGION=$(echo "${S3_CREDENTIALS}" | jq -r '.credentials.region')

    echo "Setting CORS policy on ${SERVICE_INSTANCE_NAME} (will retry if credentials are not immediately accepted)"
    while true; do
	echo " . "
	### Upload the CORS policy to the bucket
	aws s3api put-bucket-cors --bucket $BUCKET_NAME --cors-configuration '{
	  "CORSRules": [
	    {
	      "AllowedOrigins": [
		   "https://cms.usa.gov",
		   "https://www.usa.gov",
		   "https://usa.gov",
		   "https://beta-stage.usa.gov",
		   "https://cms-stage.usa.gov",
		   "https://beta-dev.usa.gov",
		   "https://cms-dev.usa.gov",
		   "http://localhost"
	      ],
	      "AllowedHeaders": ["*"],
	      "AllowedMethods": ["HEAD", "GET"],
	      "ExposeHeaders": ["ETag"]
	    }
	  ]
	}'
	if [ "$?" == "0" ]; then
	   break
	fi
    done

    echo "CORs configuration set. Confirming (again with retry):"
    while true; do
	echo " . "
	aws s3api get-bucket-cors --bucket $BUCKET_NAME
	if [ "$?" == "0" ]; then
	   break
	fi
    done

    cf delete-service-key -f "${SERVICE_INSTANCE_NAME}" "${KEY_NAME}"
}
