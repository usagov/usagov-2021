#!/bin/env bash

source ~/.profile &> /dev/null

# we might be running in circleci
if [ -f /home/circleci/project/env.local ]; then
  . /home/circleci/project/env.local
fi
# we might be running from a local dev machine
SCRIPT_DIR="$(dirname "$0")"
if [ -f $SCRIPT_DIR/env.local ]; then
  . $SCRIPT_DIR/env.local
fi
if [ -f ./env.local ]; then
  . ./env.local
fi

if [ ! command -v cf &> /dev/null ]; then
  echo "CF : the cloud foundry client could not be found and is required"
  exit 1
fi

if [ ! command -v jq &> /dev/null ]; then
  echo "JQ: the command jq could not be found and is required"
  exit 2
fi

### NOTE: the SPACE argument is for telling the cf log API to filter the request by org and space guid.
###       This appears not to work, as we are getting logs for all spaces.  Perhaps the query is incorrect?
SPACE=${1:-NONE_SPECIFIED}
SPACE=$(echo "$SPACE" | tr '[:upper:]' '[:lower:]')
if [ $SPACE = 'none_specified' ]; then
  echo "Please provide a CF Space name as the first argument"
  exit 3
fi
shift

# Grab the starting space and org where the command was run
startorg=$(     cf target | grep org:   | awk '{ print $2 }')
startspace=$( cf target | grep space: | awk '{ print $2 }')

# Drop them off where we found them
function popspace() {
  if [ -n "$startorg" ] && [ -n "$startspace" ]; then
    #echo "Popspace: ${startorg}/${startspace}"
    cf target -o "$startorg" -s "$startspace" > /dev/null 2>&1
  fi
}

trap popspace EXIT
trap popspace ERR

SFAIL=0
cf space $SPACE &>/dev/null || SFAIL=1
if [ $SFAIL = 1 ]; then
  echo "ERROR: CF space '$SPACE' does not exist!"
  exit 4
fi

SPACE_GUID=$(cf space $SPACE --guid)

cf target -s $SPACE &>/dev/null

declare -A SPACE_GUIDS=()
if [  1 -eq 1 ]; then
  for SPACE in dev stage prod shared-egress shared-egress-dr tools; do
    if [ ! cf space $SPACE &> /dev/null ]; then
      echo "ERROR: CF space '$SPACE' does not exist!"
#      exit 4
    else
      SPACE_GUID=$(cf space $SPACE --guid)
      SPACE_GUIDS[$SPACE_GUID]=$SPACE
    fi
  done

### FIXME:  Much faster.  But please usse only during testing!
else
  SPACE_GUIDS['34c660a9-0c3d-4798-8c57-c75e8252945f']="stage"
  SPACE_GUIDS['ea450105-895e-4a33-9541-6a0df35ee626']="dev"
  SPACE_GUIDS['eb4b21d8-77f0-452b-a317-22d5f2dc976e']="tools"
  SPACE_GUIDS['f717b614-a1ab-460e-bb50-6f3733700ea9']="prod"
  SPACE_GUIDS['d8e00e34-5101-460c-9962-582349b9a9e9']="dev-dr"
  SPACE_GUIDS['940eff23-9f55-406c-8514-0456cd23e360']="shared-egress"
  SPACE_GUIDS['ba235eab-3bda-4468-8e39-dfa3a67c9c6f']="shared-egress-dr"
fi

### We'll request logs generated after LAST_EVENT_TIME.  If nothing was 
### specified on the command line, start from 24 hours ago
LAST_EVENT_TIME=$1
if [ -n "$LAST_EVENT_TIME" ]; then
  ### Convert to UTC (if it's already UTC, no harm done)
  LAST_EVENT_TIME=$(TZ=UTC date -d "$LAST_EVENT_TIME" +"%Y-%m-%dT%H:%M:%SZ")
else
  LAST_EVENT_TIME=$(TZ=UTC date -d "now - 24 hours" +"%Y-%m-%dT%H:%M:%SZ")
fi

CURRENT_ORG=$(cf target | grep org: | awk '{ print $2 }')

export ORG_GUID=$(cf org $CURRENT_ORG --guid)

declare -rA AUDIT_TYPES=(
    ["app"]="audit.app.create,audit.app.start,audit.app.restage,audit.app.stop,audit.app.delete"
    ["user"]="audit.user.space_developer_add,audit.user.space_developer_remove,audit.user.space_auditor_add,audit.user.space_auditor_remove,audit.user.space_manager_add,audit.user.space_manager_remove"
    ["route"]="audit.route.create,audit.route.delete-request,audit.route.update"
    ["service"]="audit.service.create,audit.service.delete,audit.service.update,audit.service_binding.create,audit.service_binding.delete,service_instance.bind_route,audit.service_instance.create,audit.service_instance.delete,audit.service_instance.unbind_route,audit.service_instance.update"
    ["service_instance"]="audit.service_instance.create,audit.service_instance.bind_route,audit.service_instance.update,audit.service_instance.unbind_route,audit.service_instance.delete"
)

### These are the same currently, but may change. Therefore I've got them in variables for now
declare -rA AUDIT_FIELDS=(
                 ["app"]=".metadata.guid, .entity.timestamp, .entity.type, .entity.actee_name, .entity.space_guid, .entity.actor_type, .entity.actor_name"
                ["user"]=".metadata.guid, .entity.timestamp, .entity.type, .entity.actee_name, .entity.space_guid, .entity.actor_type, .entity.actor_name"
               ["route"]=".metadata.guid, .entity.timestamp, .entity.type, .entity.actee_name, .entity.space_guid, .entity.actor_type, .entity.actor_name"
             ["service"]=".metadata.guid, .entity.timestamp, .entity.type, .entity.actee_name, .entity.space_guid, .entity.actor_type, .entity.actor_name"
    ["service_instance"]=".metadata.guid, .entity.timestamp, .entity.type, .entity.actee_name, .entity.space_guid, .entity.actor_type, .entity.actor_name"
)

for resource_type in ${!AUDIT_TYPES[@]}; do
    types=${AUDIT_TYPES[$resource_type]}
    fields=${AUDIT_FIELDS[$resource_type]}

    NEXT="/v2/events?&q=type+IN+${types}&q=organization_guid:${ORG_GUID}&a=space_guid:${SPACE_GUID}&q=timestamp>${LAST_EVENT_TIME}&order-by:timestamp"

    while [ -n $NEXT -a ! $NEXT == 'null' ]; do

        EVENTS=$(cf curl $NEXT)

        captured_events=$(echo "$EVENTS" | jq -r ".resources[] | [$fields] | @csv")

        for SPACE_GUID in "${!SPACE_GUIDS[@]}"; do
          captured_events=$(echo "$captured_events" | sed "s/$SPACE_GUID/${SPACE_GUIDS[$SPACE_GUID]}/")
        done

        if [ "$captured_events" != "" ]; then
          echo "$captured_events"
        fi
        NEXT=$(echo $EVENTS | jq -r '.next_url')
    done
done
