#!/usr/bin/env bash
#
# This script will compile a report of our cf env's components
#

# Styling variables
underline=`tput smul`
nounderline=`tput rmul`
bold=`tput bold`
normal=`tput sgr0`
level2="  "
level3="    "
level4="      "
level5="        "
level6="          "

die() { echo "$*" >&2; exit 2; }  # complain to STDERR and exit with error
needs_arg() { if [ -z "$OPTARG" ]; then die "No arg for --$OPT option"; fi; }

# Defaults (to be thorough, you could also assign alpha="" and charlie="")
all=false       # Overridden by the value set by -b or --bravo
spaces="all"       # Overridden by the value set by -s or --spaces

while getopts as: OPT; do  # allow -a, -b with arg, and -- "with arg"
  # support long options: https://stackoverflow.com/a/28466267/519360
  if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
    OPT="${OPTARG%%=*}"       # extract long option name
    OPTARG="${OPTARG#"$OPT"}" # extract long option argument (may be empty)
    OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
  fi
  case "$OPT" in
    a | all )      all=true ;;
    s | spaces )   needs_arg; spaces="$OPTARG" ;;
    \? )           exit 2 ;;  # bad short option (error reported via getopts)
    * )            die "Illegal option --$OPT" ;;  # bad long option
  esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

echo "${bold}${underline}CF Components${nounderline}${normal}"

# Orgs->Domains/Spaces->Apps/Services->Tasks/Sidecars
if [ $all == true ]; then
  ORGIDS=$(cf curl "/v3/organizations" | jq -r '[.resources[].guid]')
else
  echo "Showing info for gsa-tts-usagov, add --all argument to see all orgs."
  ORGIDS=$(cf curl "/v3/organizations" | jq -r '[.resources[] | select(.name == "gsa-tts-usagov") | .guid]')
fi

IFS=',' read -r -a spaces_array <<< "$spaces"

echo "$ORGIDS" | jq -r '.[]' | while read -r ORGID; do
  ORGNAME=$(cf curl "/v3/organizations/$ORGID" | jq -r '.name')
  ORGUPDATE=$(cf curl "/v3/organizations/$ORGID" | jq -r '.updated_at')

  echo "Org: ${underline}$ORGNAME${nounderline} (Last updated: $ORGUPDATE)"

  DOMIANIDS=$(cf curl "/v3/domains" | jq -r '[.resources[] | select( .relationships.organization.data.guid == "'$ORGID'" ) | .guid]')
  if [ "$DOMIANIDS" != "[]" ]; then
    echo "$level2 Domains:"
    echo "$DOMIANIDS" | jq -r '.[]' | while read -r DOMIANID; do
      DOMAINNAME=$(cf curl "/v3/domains/$DOMIANID" | jq -r '.name')
      DOMAINUPDATED=$(cf curl "/v3/domains/$DOMIANID" | jq -r '.updated_at')
      DOMAININTERNAL=$(cf curl "/v3/domains/$DOMIANID" | jq -r '.internal')
      DOMAINPROTOCOLS=$(cf curl "/v3/domains/$DOMIANID" | jq -c '.supported_protocols')
      echo "$level3 $DOMAINNAME (Last updated: $DOMAINUPDATED | Internal: $DOMAININTERNAL | Supported Protocols: $DOMAINPROTOCOLS)"
    done
  fi

 if [ $spaces == "all" ]; then
  SPACEIDS=$(cf curl "/v3/spaces" | jq -r '.resources[] | select( .relationships.organization.data.guid == "'$ORGID'" ) | .guid')
 else
  SPACEIDS=$(cf curl "/v3/spaces" | jq -r '.resources[] | select( .relationships.organization.data.guid == "'$ORGID'" ) | .guid' | while read -r SPACEID; do
    SPACENAME=$(cf curl "/v3/spaces/$SPACEID" | jq -r '.name')
    for space in "${spaces_array[@]}"; do
      if [[ "$space" == "$SPACENAME" ]]; then
        echo "$SPACEID"
      fi
    done
  done)
 fi

 echo "$SPACEIDS" | while read -r SPACEID; do
  SPACENAME=$(cf curl "/v3/spaces/$SPACEID" | jq -r '.name')
  SPACEUPDATE=$(cf curl "/v3/spaces/$SPACEID" | jq -r '.updated_at')
  echo "$level2 Space: ${underline}$SPACENAME${nounderline} (Last updated: $SPACEUPDATE)"

  SERVICEIDS=$(cf curl "/v3/service_instances" | jq -r '[.resources[] | select( .relationships.space.data.guid == "'$SPACEID'" ) | .guid]')
  if [ "$SERVICEIDS" != "[]" ]; then
    echo "$level3 Services:"
    echo "$SERVICEIDS" | jq -r '.[]' | while read -r SERVICEID; do
      SERVICELASTOPERATION=""
      SERVICENAME=$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.name')
      SERVICEUPDATED=$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.updated_at')
      if [ "$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.last_operation')" != "{}" ]; then
        SERVICETYPE=$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.last_operation.type')
        SERVICESTATE=$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.last_operation.state')
        SERVICEDESCRIPTION=$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.last_operation.description')
        SERVICEUPDATED=$(cf curl "/v3/service_instances/$SERVICEID" | jq -r '.last_operation.updated_at')

        SERVICELASTOPERATION="(Last operation at $SERVICEUPDATED; Type: $SERVICETYPE | State: $SERVICESTATE | Description: $SERVICEDESCRIPTION)"
      fi
      echo "$level4 $SERVICENAME Last updated: $SERVICEUPDATED $SERVICELASTOPERATION"
    done
  fi

  ROUTEIDS=$(cf curl "/v3/routes" | jq -r '[.resources[] | select( .relationships.space.data.guid == "'$SPACEID'" ) | .guid]')
  if [ "$ROUTEIDS" != "[]" ]; then
    echo "$level3 Routes:"
    echo "$ROUTEIDS" | jq -r '.[]' | while read -r ROUTEID; do
      ROUTENAME=$(cf curl "/v3/routes/$ROUTEID" | jq -r '.name')
      ROUTEUPDATED=$(cf curl "/v3/routes/$ROUTEID" | jq -r '.updated_at')
      ROUTEHOST=$(cf curl "/v3/routes/$ROUTEID" | jq -r '.host')
      ROUTEPATH=$(cf curl "/v3/routes/$ROUTEID" | jq -r '.path')
      ROUTEURL=$(cf curl "/v3/routes/$ROUTEID" | jq -r '.url')
      echo "$level4 $ROUTENAME (Last updated: $ROUTEUPDATED | Host: $ROUTEHOST | Path: $ROUTEPATH | URL: $ROUTEURL)"
    done
  fi

  APPIDS=$(cf curl "/v3/apps" | jq -r '[.resources[] | select( .relationships.space.data.guid == "'$SPACEID'" ) | .guid]')
  if [ "$APPIDS" != "[]" ]; then
    echo "$level3 Apps:"
    echo "$APPIDS" | jq -r '.[]' | while read -r APPID; do
      APPNAME=$(cf curl "/v3/apps/$APPID" | jq -r '.name')
      APPUPDATED=$(cf curl "/v3/apps/$APPID" | jq -r '.updated_at')
      APPSTATE=$(cf curl "/v3/apps/$APPID" | jq -r '.state')
      APPTYPE=$(cf curl "/v3/apps/$APPID" | jq -r '.lifecycle.type')

      if [ "$APPTYPE" != "docker" ]; then
        APPBUILDPACKS=$(cf curl "/v3/apps/$APPID" | jq -c '.lifecycle.data.buildpacks')
        APPSTACK=$(cf curl "/v3/apps/$APPID" | jq -c '.lifecycle.data.stack')
        APPSTACKINFO=" | Buildpacks: $APPBUILDPACKS | Stack: $APPSTACK"
      fi
      echo "$level4 $APPNAME (Last updated: $APPUPDATED | State: $APPSTATE | Type: $APPTYPE$APPSTACKINFO)"

      TASKCOUNT=$(cf curl "/v3/apps/$APPID/tasks" | jq -r '.pagination | .total_results')
      if [ "$TASKCOUNT" != "[]" ]; then
        echo "$level5 Number of Tasks attached to $APPNAME: $TASKCOUNT"
      fi
      SIDECARIDS=$(cf curl "/v3/apps/$APPID/sidecars" | jq -r '[.resources[] | .guid]')
      if [ "$SIDECARIDS" != "[]" ]; then
        echo "$level5 Sidecars:"
        echo "$SIDECARIDS" | jq -r '.[]' | while read -r SIDECARID; do
          SIDECARNAME=$(cf curl "/v3/sidecars/$SIDECARID" | jq -r '.name')
          SIDECARUPDATED=$(cf curl "/v3/sidecars/$SIDECARID" | jq -r '.updated_at')
          SIDECARCOMMAND=$(cf curl "/v3/sidecars/$SIDECARID" | jq -r '.command')
          SIDECARPROCESS=$(cf curl "/v3/sidecars/$SIDECARID" | jq -c '.process_types')
          SIDECARMEMORY=$(cf curl "/v3/sidecars/$SIDECARID" | jq -r '.memory_in_mb')
          SIDECARORIGIN=$(cf curl "/v3/sidecars/$SIDECARID" | jq -r '.origin')
          echo "$level6 $SIDECARNAME (Last updated: $SIDECARUPDATED |Command: $SIDECARCOMMAND | Process Types: $SIDECARPROCESS | Memory: $SIDECARMEMORY mb | Origin: $SIDECARORIGIN)"
        done
      fi
      DROPLETIDS=$(cf curl "/v3/apps/$APPID/sidecars" | jq -r '[.resources[] | .guid]')
      if [ "$DROPLETIDS" != "[]" ]; then
        echo "$level5 Droplets:"
        echo "$DROPLETIDS" | jq -r '.[]' | while read -r DROPLETID; do
          DROPLETNAME=$(cf curl "/v3/sidecars/$DROPLETID" | jq -r '.name')
          DROPLETUPDATED=$(cf curl "/v3/sidecars/$DROPLETID" | jq -r '.updated_at')
          DROPLETSTACK=$(cf curl "/v3/sidecars/$DROPLETID" | jq -r '.stack')
          DROPLETSTACKOUT=""
          if [ "$DROPLETSTACK" != "null" ]; then
            DROPLETSTACKOUT=" | Stack: $DROPLETSTACK"
          fi
          DROPLETIMAGEOUT=""
          DROPLETIMAGE=$(cf curl "/v3/sidecars/$DROPLETID" | jq -r '.image')
          if [ "$DROPLETIMAGE" != "null" ]; then
            DROPLETIMAGEOUT=" | Image: $DROPLETIMAGE"
          fi
          echo "$level6 $DROPLETNAME (Last updated: $DROPLETUPDATED$DROPLETSTACKOUT$DROPLETIMAGEOUT)"
        done
      fi
    done
  fi
 done
 echo "${underline}                                                                                                         ${nounderline}
 "
done

# Misc info
if [ $all == true ]; then
  echo "Showing all orgs.  For security reasons, the display of users is suppressed.  Remove -a argument to see users for gsa-tts-usagov org."
else
  USERIDS=$(cf curl "/v3/users" | jq -r '[.resources[] | .guid]')
  if [ "$USERIDS" != "[]" ]; then
    echo "${underline}Users:${nounderline}"
    echo "$USERIDS" | jq -r '.[]' | while read -r USERID; do
      USERNAME=$(cf curl "/v3/users/$USERID" | jq -r '.username')
      USERPUPDATE=$(cf curl "/v3/users/$USERID" | jq -r '.updated_at')
      USERPRESENTATION=$(cf curl "/v3/users/$USERID" | jq -r '.presentation_name')
      USERORIGIN=$(cf curl "/v3/users/$USERID" | jq -r '.origin')
      echo "$level2 $USERNAME (Last updated: $USERPUPDATE | Presentation Name: $USERPRESENTATION | Origin: $USERORIGIN)"
    done
  fi
fi

GROUPIDS=$(cf curl "/v3/security_groups" | jq -r '[.resources[] | .guid]')
if [ "$GROUPIDS" != "[]" ]; then
  echo "${underline}Security Groups:${nounderline}"
  echo "$GROUPIDS" | jq -r '.[]' | while read -r GROUPID; do
    GROUPNAME=$(cf curl "/v3/security_groups/$GROUPID" | jq -r '.name')
    GROUPUPDATED=$(cf curl "/v3/security_groups/$GROUPID" | jq -r '.updated_at')
    GROUPRULES=$(cf curl "/v3/security_groups/$GROUPID" | jq -r '.rules')
    echo "$level2 $GROUPNAME (Last updated: $GROUPUPDATED)"
    echo "$level3 Rules:"
    echo "$level4 $GROUPRULES"
  done
fi
