#!/usr/bin/env bash

# we might be running in circleci
if [ -f /home/circleci/project/env.local ]; then
  . /home/circleci/project/env.local
fi
# we might be running from a local dev machine
SCRIPT_DIR="$(dirname "$0")"
if [ -f $SCRIPT_DIR/env.local ]; then
  . $SCRIPT_DIR/env.local
fi
if [ -f ./env.local ]; then
  . ./env.local
fi

if [ -f $SCRIPT_DIR/../deploy/includes ]; then
  . $SCRIPT_DIR/../deploy/includes
else
   echo Cannot find $SCRIPT_DIR/../deploy/includes
   exit 1
fi

export BUCKET_SOURCE_FOLDER=public
if [ -f ./bin/snapshot-backups/snapshot-include ]; then
  . ./bin/snapshot-backups/snapshot-include
else
   echo Cannot find ${PWD}/bin/snapshot-backups/snapshot-include
   exit 1
fi
if [ -f $SCRIPT_DIR/../deploy/includes ]; then
  . $SCRIPT_DIR/../deploy/includes
else
   echo Cannot find $SCRIPT_DIR/../deploy/includes
   exit 1
fi

# just testing?
if [ x$1 = x"--dryrun" ]; then
  echo=echo
  dryrun=$1
  shift
fi

SPACE=$1
if [ -z $SPACE ]; then
  echo "Usage:"
  echo "$0 [--dryrun] <env> [--partial <eg. USAGOV-9999> | --full <eg. USAGOV-9999.dev.1111.post-deploy.2020010101] [--download]"
  echo ""
  echo "--dryrun MUST be the first argument, or it WILL NOT BE ACKNOWLEDGED"
  echo "--partial <string> - partial match (eg. USAGOV-9999 will match all snapshots for ticket USAGOV-9999)"
  echo "--full <string>    - full match    (string must match the full snapshot tag)"
  echo "--download will download a copy of the snapshot(s) before deleting them"
  exit 1
fi

SPACE=$(echo "$SPACE" | tr '[:upper:]' '[:lower:]')
assertCurSpace $SPACE
shift

removeTag=""
removeTicket=""
download=""
match=""
rematch=""

while [ 0 -eq 0 ]; do

  matchtype=$1

  if [ -z "$matchtype" ]; then
    break
  fi
  shift

  grepCommand=""

  case "$matchtype" in

      "--partial")
        match=$1
        if [ -n "$match" ]; then
          if [ $match = "--download" ]; then
            match=""
          fi
          shift
        fi
      ;;

      "--full")
        match=$1
        if [ -n "$match" ]; then
          if [ $match = "--download" ]; then
            match=""
          else
            rematch="^${match//./\\\.}$"
          fi
          shift
        fi
      ;;

      "--download")
        download="--download"
      ;;
  esac

done

if [ -z "$match" ]; then
  echo "Usage:"
  echo "$0 [--dryrun] <env> [--partial <eg. USAGOV-9999> | --full <eg. USAGOV-9999.dev.1111.post-deploy.2020010101] [--download]"
  echo ""
  echo "--dryrun MUST be the first argument, or it WILL NOT BE ACKNOWLEDGED"
  echo "--partial <string> - partial match (eg. USAGOV-9999 will match all snapshots for ticket USAGOV-9999)"
  echo "--full <string>    - full match    (string must match the full snapshot tag)"
  echo "--download will download a copy of the snapshot(s) before deleting them"
  exit 1
fi

basename "$0"
echo "Dry run:       $dryrun"
echo "Download:      $download"
echo "Match:         $match"
echo "Regex Match:   $rematch"

source bin/cloudgov/get-s3-access storage >/dev/null 2>&1

export site_available_tags=$(aws s3 ls s3://$S3_BUCKET/web-backup/ | awk '{print $NF}' | sed 's/[\/ ]*$//g')
export public_available_tags=$(aws s3 ls s3://$S3_BUCKET/$BUCKET_BACKUP_FOLDER/ | awk '{print $NF}' | sed 's/[\/ ]*$//g')
export db_available_tags=$(aws s3 ls s3://$S3_BUCKET/db-backup/ | awk '{print $NF}' | sed 's/[\/ ]*$//g' | sed 's/\.sql\.gz//g')

if [ -n "$rematch" ]; then
  for tag in $(echo $db_available_tags | tr ' ' '\n' | sort | uniq | grep -E $rematch ); do
    $echo $(dirname $0)/db-snapshot-delete $dryrun $SPACE $match $download
  done

  for tag in $(echo $site_available_tags | tr ' ' '\n' | sort | uniq | grep -E $rematch ); do
    $echo $(dirname $0)/site-snapshot-delete $dryrun $SPACE $match $download
  done

  for tag in $(echo $public_available_tags | tr ' ' '\n' | sort | uniq | grep -E $rematch); do
    $echo $(dirname $0)/public-snapshot-delete $dryrun $SPACE $match $download
  done
else
  for tag in $(echo $db_available_tags | tr ' ' '\n' | sort | uniq | grep $match ); do
    $echo $(dirname $0)/db-snapshot-delete $dryrun $SPACE $match $download
  done

  for tag in $(echo $site_available_tags | tr ' ' '\n' | sort | uniq | grep $match ); do
    $echo $(dirname $0)/site-snapshot-delete $dryrun $SPACE $match $download
  done

  for tag in $(echo $public_available_tags | tr ' ' '\n' | sort | uniq | grep $match); do
    $echo $(dirname $0)/public-snapshot-delete $dryrun $SPACE $match $download
  done
fi
